diff --git a/adapter.c b/adapter.c
index 285faea..6ca7dd5 100755
--- a/adapter.c
+++ b/adapter.c
@@ -33,6 +33,9 @@
 #include "socketworks.h"
 #include "dvb.h"
 #include "adapter.h"
+#ifdef AXE
+#include "axe.h"
+#endif
 
 adapter a[MAX_ADAPTERS];
 extern struct struct_opts opts;
@@ -49,7 +52,12 @@ find_adapters ()
 	for (i = 0; i < 8; i++)
 		for (j = 0; j < 8; j++)
 	{
+#ifdef AXE
+		if (j > 0) continue;
+		sprintf (buf, "/dev/axe/frontend-%d", i);
+#else
 		sprintf (buf, "/dev/dvb/adapter%d/frontend%d", i, j);
+#endif
 		fd = open (buf, O_RDONLY | O_NONBLOCK);
 		//LOG("testing device %s -> fd: %d",buf,fd);
 		if (fd >= 0)
@@ -122,9 +130,18 @@ init_hw ()
 			find_adapters ();
 		LOG ("trying to open [%d] adapter %d and frontend %d", i, a[i].pa,
 			a[i].fn);
+#ifdef AXE
+		sprintf (buf, "/dev/axe/frontend-%d", a[i].pa);
+#else
 		sprintf (buf, "/dev/dvb/adapter%d/frontend%d", a[i].pa, a[i].fn);
+#endif
 		a[i].fe = open (buf, O_RDWR | O_NONBLOCK);
+
+#ifdef AXE
+		sprintf (buf, "/dev/axe/demuxts-%d", a[i].pa);
+#else
 		sprintf (buf, "/dev/dvb/adapter%d/dvr%d", a[i].pa, a[i].fn);
+#endif
 		a[i].dvr = open (buf, O_RDONLY | O_NONBLOCK);
 		if (a[i].fe < 0 || a[i].dvr < 0)
 		{
@@ -151,10 +168,12 @@ init_hw ()
 
 		num_adapters++;
 		LOG ("opened DVB adapter %d fe:%d dvr:%d", i, a[i].fe, a[i].dvr);
+#ifndef AXE
 		if (ioctl (a[i].dvr, DMX_SET_BUFFER_SIZE, opts.dvr) < 0)
 			perror ("couldn't set DVR buffer size");
 		else
 			LOG ("Done setting DVR buffer to %d bytes", DVR_BUFFER);
+#endif
 		init_dvb_parameters (&a[i].tp);
 		mark_pids_deleted (i, -1, NULL);
 		update_pids (i);
@@ -194,6 +213,22 @@ close_adapter (int na)
 	mark_pids_deleted (na, -1, NULL);
 	update_pids (na);
 	//      if(a[na].dmx>0)close(a[na].dmx);
+#ifdef AXE
+	if (a[na].fe > 0) {
+		int i;
+		axe_fe_reset(a[na].fe);
+		for (i = 0; i < 4; i++)
+			if (i != na && a[i].fe > 0) break;
+		if (i >= 4) {
+			LOG("AXE standby");
+			axe_fe_standby(a[na].fe, -1);
+		} else {
+			LOG("AXE standby: adapter %d busy, keeping", i);
+		}
+		ioctl(a[na].fe, FE_SET_VOLTAGE, SEC_VOLTAGE_OFF);
+		a[na].tp.old_diseqc = a[na].tp.old_pol = a[na].tp.old_hiband = -1;
+	}
+#endif
 	if (a[na].fe > 0)
 		close (a[na].fe);
 	if (a[na].sock >= 0)
@@ -366,7 +401,30 @@ close_adapter_for_stream (int sid, int aid)
 								 // delete the attached PIDs as well
 	mark_pids_deleted (aid, sid, NULL);
 	update_pids (aid);
-//	if (a[aid].sid_cnt == 0) 
+#ifdef AXE
+	if (a[aid].sid_cnt == 0) {
+		int i;
+		char buf[50];
+		axe_fe_reset(a[aid].fe);
+		for (i = 0; i < 4; i++)
+			if (i != aid && a[i].sid_cnt > 0) break;
+		if (i >= 4) {
+			LOG("AXE standby");
+			axe_fe_standby(a[aid].fe, -1);
+		} else {
+			LOG("AXE standby: adapter %d busy, keeping", i);
+		}
+		ioctl(a[aid].fe, FE_SET_VOLTAGE, SEC_VOLTAGE_OFF);
+		a[aid].tp.old_diseqc = a[aid].tp.old_pol = a[aid].tp.old_hiband = -1;
+		sockets_del(a[aid].sock);
+		sprintf (buf, "/dev/axe/demuxts-%d", a[i].pa);
+		a[aid].dvr = open (buf, O_RDONLY | O_NONBLOCK);
+		a[i].sock =
+			sockets_add (a[i].dvr, NULL, i, TYPE_DVR, (socket_action) read_dmx,
+			(socket_action) close_adapter_for_socket, (socket_action ) adapter_timeout);
+	}
+#endif
+//	if (a[aid].sid_cnt == 0)
 //		close_adapter (aid);
 }
 
@@ -684,7 +742,11 @@ describe_adapter (int sid, int aid)
 	memset (dad, 0, sizeof (dad));
 	x = 0;
 								 // do just max 3 signal check 1s after tune
+#ifndef AXE
 	if (use_ad && ((ad->status <= 0 && ad->status_cnt<8 && ad->status_cnt++>4) || opts.force_scan))
+#else
+	if (use_ad && (ad->status_cnt++ & 3) == 0)
+#endif
 	{
 		int new_gs = 1;
 		ts = getTick ();
@@ -701,11 +763,20 @@ describe_adapter (int sid, int aid)
 		if (ad->max_snr <= ad->snr) ad->max_snr = (ad->snr>0)?ad->snr:1;
 		LOG ("get_signal%s took %d ms for adapter %d handle %d (status: %d, ber: %d, strength:%d, snr: %d, max_strength: %d, max_snr: %d %d)",
 			new_gs?"":"_new", getTick () - ts, aid, ad->fe, ad->status, ad->ber, ad->strength, ad->snr, ad->max_strength, ad->max_snr, opts.force_scan);
+#ifndef AXE
 		if(new_gs)
 		{
 			ad->strength = ad->strength * 255 / ad->max_strength;
 			ad->snr = ad->snr * 15 / ad->max_snr;
 		}
+#else
+		ad->strength = ad->strength * 240 / 9000;
+		if (ad->strength > 240)
+			ad->strength = 240;
+		ad->snr = ad->snr * 15 / 54000;
+		if (ad->snr > 15)
+			ad->snr = 15;
+#endif
 	}
 	if(use_ad)
 	{
@@ -715,14 +786,14 @@ describe_adapter (int sid, int aid)
 	}
 	if (t->sys == SYS_DVBS || t->sys == SYS_DVBS2)
 		sprintf (dad, "ver=1.0;src=%d;tuner=%d,%d,%d,%d,%d,%s,%s,%s,%s,%s,%d,%s;pids=",
-			t->diseqc, aid, strength, status, snr, t->freq / 1000, get_pol(t->pol), get_modulation(t->mtype), 
+			t->diseqc, aid+1, strength, status, snr, t->freq / 1000, get_pol(t->pol), get_modulation(t->mtype), 
 			get_pilot(t->plts), get_rolloff(t->ro), get_delsys(t->sys), t->sr / 1000, get_fec(t->fec));
 	else if (t->sys == SYS_DVBT || t->sys == SYS_DVBT2)
 		sprintf (dad, "ver=1.1;src=%d;tuner=%d,%d,%d,%d,%.2f,%d,%s,%s,%s,%s,%s,%d,%d,%d;pids=",
-			t->diseqc, aid, strength, status, snr, (double) t->freq/1000, t->bw, get_delsys(t->sys), get_tmode(t->tmode), get_modulation(t->mtype), get_gi(t->gi),
+			t->diseqc, aid+1, strength, status, snr, (double) t->freq/1000, t->bw, get_delsys(t->sys), get_tmode(t->tmode), get_modulation(t->mtype), get_gi(t->gi),
 			get_fec(t->fec), t->plp, t->t2id, t->sm);
 	else  sprintf (dad, "ver=1.2;src=%d;tuner=%d,%d,%d,%d,%.2f,8,%s,%s,%d,%d,%d,%d,%d;pids=",
-                        t->diseqc, aid, strength, status, snr, (double )t->freq/1000, get_delsys(t->sys), get_modulation(t->mtype), t->sr,
+                        t->diseqc, aid+1, strength, status, snr, (double )t->freq/1000, get_delsys(t->sys), get_modulation(t->mtype), t->sr,
 						t->c2tft, t->ds, t->plp, t->inversion);
 	for (i = 0; i < MAX_PIDS; i++)
 		if (use_ad && ad->pids[i].flags == 1)
diff --git a/axe.h b/axe.h
new file mode 100644
index 0000000..5af4c73
--- /dev/null
+++ b/axe.h
@@ -0,0 +1,59 @@
+#ifndef __AXE_H
+#define __AXE_H
+
+#include <linux/dvb/dmx.h>
+#include <linux/dvb/frontend.h>
+
+typedef struct fe_frontend_status fe_frontend_status_t;
+
+struct fe_frontend_status {
+  __u32 val0;
+  __u32 val1;
+  __u32 val2;
+  __u32 modulation;
+  __u32 val4;
+  __u32 frequency;
+  __u32 val6;
+  __u32 val7;
+  __u32 symbol_rate;
+  __u32 val9;
+  __u32 fec;
+  __u32 rolloff;
+  __u32 val12;
+  __u32 val13;
+} __attribute__ ((packed));
+
+#define FE_FRONTEND_STANDBY     _IOW('o', 91, __u32)
+#define FE_FRONTEND_RESET	_IO('o', 93)
+#define FE_FRONTEND_STATUS      _IOR('o', 96, fe_frontend_status_t)
+#define FE_FRONTEND_THREAD_UP	_IOW('o', 97, __u8)
+
+static inline int axe_fe_standby(int fd, __u32 stdby)
+{
+  return ioctl(fd, FE_FRONTEND_STANDBY, &stdby);
+}
+
+static inline int axe_fe_reset(int fd)
+{
+  return ioctl(fd, FE_FRONTEND_RESET, 0x54);
+}
+
+static inline int axe_fe_thread_up(int fd, __u8 up)
+{
+  return ioctl(fd, FE_FRONTEND_THREAD_UP, &up);
+}
+
+#define DMXTS_ADD_PID     _IOW('o', 1, __u16)
+#define DMXTS_REMOVE_PID  _IOW('o', 2, __u16)
+
+static inline int axe_dmxts_add_pid(int fd, __u16 pid)
+{
+  return ioctl(fd, DMXTS_ADD_PID, &pid);
+}
+
+static inline int axe_dmxts_remove_pid(int fd, __u16 pid)
+{
+  return ioctl(fd, DMXTS_REMOVE_PID, &pid);
+}
+
+#endif
diff --git a/dvb.c b/dvb.c
index 5701bd2..bfb1cdd 100755
--- a/dvb.c
+++ b/dvb.c
@@ -41,6 +41,10 @@
 #include <ctype.h>
 #include "dvb.h"
 #include "minisatip.h"
+#ifdef AXE
+#include "axe.h"
+#include "adapter.h"
+#endif
 
 extern struct struct_opts opts;
 
@@ -343,6 +347,13 @@ int setup_switch (int frontend_fd, transponder *tp)
 		else 
 			LOGL(3, "Skip sending diseqc commands since the switch position doesn't need to be changed: pol %d, hiband %d, switch position %d", pol, hiband, diseqc);
 	}
+#ifdef AXE
+	LOGL(3, "axe_fe: reset for fd %d", frontend_fd);
+	if (axe_fe_reset(frontend_fd) < 0)
+		LOG("axe_fe: RESET failed for fd %d: %s", frontend_fd, strerror(errno));
+	if (axe_fe_thread_up(frontend_fd, hiband | (pol << 1)) < 0)
+		LOG("axe_fe: THREAD UP failed for fd %d: %s", frontend_fd, strerror(errno));
+#endif
 	
 	tp->old_pol = pol;
 	tp->old_hiband = hiband;
@@ -383,8 +394,10 @@ tune_it_s2 (int fd_frontend, transponder * tp)
 		{.cmd = DTV_INVERSION,.u.data = 0},
 		{.cmd = DTV_SYMBOL_RATE,.u.data = 0},
 		{.cmd = DTV_INNER_FEC,.u.data = 0},
+#ifndef AXE
 		{.cmd = DTV_PILOT,.u.data = 0},
 		{.cmd = DTV_ROLLOFF,.u.data = 0},
+#endif
 		{.cmd = DTV_TUNE},
 	};
 	static struct dtv_properties dvbs2_cmdseq =
@@ -465,8 +478,10 @@ tune_it_s2 (int fd_frontend, transponder * tp)
 			p = &dvbs2_cmdseq;
 			p->props[DELSYS].u.data = tp->sys;
 			p->props[MODULATION].u.data = tp->mtype;
+#ifndef AXE
 			p->props[PILOT].u.data = tp->plts;
 			p->props[ROLLOFF].u.data = tp->ro;
+#endif
 			p->props[INVERSION].u.data = tp->inversion;
 			p->props[SYMBOL_RATE].u.data = tp->sr;
 			p->props[FEC_INNER].u.data = tp->fec;
@@ -475,7 +490,12 @@ tune_it_s2 (int fd_frontend, transponder * tp)
 			LOG("tuning to %d(%d) pol: %s (%d) sr:%d fec:%s delsys:%s mod:%s rolloff:%s pilot:%s, ts clear=%d, ts pol=%d",
 				tp->freq, p->props[FREQUENCY].u.data, get_pol(tp->pol), tp->pol, p->props[SYMBOL_RATE].u.data, fe_fec[p->props[FEC_INNER].u.data],
 				fe_delsys[p->props[DELSYS].u.data], fe_modulation[p->props[MODULATION].u.data],
-				fe_rolloff[p->props[ROLLOFF].u.data], fe_pilot[p->props[PILOT].u.data], bclear, bpol);
+#ifdef AXE
+				"auto", "auto",
+#else
+				fe_rolloff[p->props[ROLLOFF].u.data], fe_pilot[p->props[PILOT].u.data],
+#endif
+				bclear, bpol);
 				
 			break;
 
@@ -560,6 +580,20 @@ set_pid (int hw, int ad, uint16_t i_pid)
 	char buf[100];
 	int fd;
 
+#ifdef AXE
+	adapter *a = get_adapter(hw);
+
+	if ( i_pid > 8192 || a == NULL)
+		LOG_AND_RETURN(-1, "pid %d > 8192 for ADAPTER %d", i_pid, hw);
+
+	if (axe_dmxts_add_pid(a->dvr, i_pid) < 0)
+	{
+		LOG ("failed setting filter on %d (%s)", i_pid, strerror (errno));
+		return -1;
+	}
+	LOG ("setting filter on PID %d for ADAPTER %d", i_pid, a->pa);
+	return (hw << 16) | i_pid;
+#else
 	if ( i_pid > 8192 )
 		LOG_AND_RETURN(-1, "pid %d > 8192 for /dev/dvb/adapter%d/demux%d", i_pid, hw, ad);
 		
@@ -585,6 +619,7 @@ set_pid (int hw, int ad, uint16_t i_pid)
 	}
 
 	LOG ("setting filter on PID %d for fd %d", i_pid, fd);
+#endif
 
 	return fd;
 }
@@ -592,6 +627,17 @@ set_pid (int hw, int ad, uint16_t i_pid)
 
 int del_filters (int fd, int pid)
 {
+#ifdef AXE
+	adapter *a = get_adapter(fd >> 16);
+	if (a == NULL)
+		return 0; /* closed */
+	if ((fd & 0xffff) != pid)
+		LOG_AND_RETURN(0, "AXE PID remove on an invalid handle %d, pid %d", fd, pid);
+	if (axe_dmxts_remove_pid(a->dvr, pid) < 0)
+		LOG ("AXE PID removew failed on PID %d ADAPTER %d: %s", pid, a->pa, strerror (errno))
+			else
+			LOG ("clearing filters on PID %d ADAPTER %d", pid, a->pa);
+#else
 	if (fd < 0)
 		LOG_AND_RETURN(0, "DMX_STOP on an invalid handle %d, pid %d", fd, pid);
 	if (ioctl (fd, DMX_STOP) < 0)
@@ -599,6 +645,7 @@ int del_filters (int fd, int pid)
 			else
 			LOG ("clearing filters on PID %d FD %d", pid, fd);
 	close (fd);
+#endif
 	return 0;
 }
 
@@ -606,6 +653,15 @@ int del_filters (int fd, int pid)
 fe_delivery_system_t
 dvb_delsys (int aid, int fd, fe_delivery_system_t *sys)
 {
+#ifdef AXE
+	int i;
+	LOG ("Delivery System DVB-S/DVB-S2 (AXE)");
+	for(i = 0 ; i < 10 ; i ++)
+		sys[i] = 0;
+	sys[0] = SYS_DVBS;
+	sys[1] = SYS_DVBS2;
+	return SYS_DVBS2;
+#else
 	int i, res, rv = 0;
 	struct dvb_frontend_info fe_info;
 
@@ -703,6 +759,7 @@ dvb_delsys (int aid, int fd, fe_delivery_system_t *sys)
 
 	LOG ("returning default from dvb_delsys => %s (count %d)", fe_delsys[rv] , nsys);
 	return (fe_delivery_system_t) rv;
+#endif
 
 }
 
diff --git a/minisatip.c b/minisatip.c
index d4076ba..581d1bd 100755
--- a/minisatip.c
+++ b/minisatip.c
@@ -483,6 +483,11 @@ http_response (sockets *s, int rc, char *ah, char *desc, int cseq, int lr)
 
 #define RBUF 4000
 
+static inline end_of_header(char *buf)
+{
+	return buf[0] == 0x0d && buf[1] == 0x0a && buf[2] == 0x0d && buf[3] == 0x0a;
+}
+
 int
 read_rtsp (sockets * s)
 {
@@ -507,8 +512,7 @@ read_rtsp (sockets * s)
 		}
 	}
 	
-	if (s->rlen < 4
-		|| (htonl (*(uint32_t *) & s->buf[s->rlen - 4]) != 0x0D0A0D0A))
+	if (s->rlen < 4 || !end_of_header(s->buf + s->rlen - 4))
 	{
 		if( s->rlen > RBUF - 10 )
 		{
@@ -726,8 +730,7 @@ read_http (sockets * s)
 		"%s"
 		"</device></root>";
 
-	if (s->rlen < 5
-		|| (htonl (*(uint32_t *) & s->buf[s->rlen - 4]) != 0x0D0A0D0A))
+	if (s->rlen < 5 || !end_of_header(s->buf + s->rlen - 4))
 	{
 		if( s->rlen > RBUF - 10 )
 		{
@@ -987,7 +990,11 @@ main (int argc, char *argv[])
 	set_options (argc, argv);
 	if (opts.daemon)
 		becomeDaemon ();
+#ifdef AXE
+	LOGL(0, "Starting minisatip version %s, compiled with AXE DVB API",VERSION);
+#else
 	LOGL(0, "Starting minisatip version %s, compiled with dvbapi version: %04X",VERSION, DVBAPIVERSION);
+#endif
 	readBootID();
 	if ((ssdp = udp_bind (NULL, 1900)) < 1)
 		FAIL ("SSDP: Could not bind on udp port 1900");
diff --git a/socketworks.c b/socketworks.c
index b4891f1..1857089 100755
--- a/socketworks.c
+++ b/socketworks.c
@@ -433,6 +433,17 @@ select_and_execute ()
 					ss->rtime = c_time;
 					if(rlen>0)
 						ss->rlen += rlen;
+#ifdef AXE
+					if (ss->type == TYPE_DVR) {
+						while (rlen > 0 && ss->lbuf - ss->rlen >= 1316) {
+							rlen = read (ss->sock, &ss->buf[ss->rlen], ss->lbuf - ss->rlen);
+							if (rlen > 0)
+								ss->rlen += rlen;
+						}
+						if (rlen == 0 || (rlen < 0 || errno == -EAGAIN))
+							rlen = 1;
+					}
+#endif
 								 //force 0 at the end of the string
 					if(ss->lbuf >= ss->rlen)
 						ss->buf[ss->rlen] = 0;
