diff --git a/adapter.c b/adapter.c
index 285faea..d3294b6 100755
--- a/adapter.c
+++ b/adapter.c
@@ -49,7 +49,12 @@ find_adapters ()
 	for (i = 0; i < 8; i++)
 		for (j = 0; j < 8; j++)
 	{
+#ifdef AXE
+		if (j > 0) continue;
+		sprintf (buf, "/dev/axe/frontend-%d", i);
+#else
 		sprintf (buf, "/dev/dvb/adapter%d/frontend%d", i, j);
+#endif
 		fd = open (buf, O_RDONLY | O_NONBLOCK);
 		//LOG("testing device %s -> fd: %d",buf,fd);
 		if (fd >= 0)
@@ -122,9 +127,18 @@ init_hw ()
 			find_adapters ();
 		LOG ("trying to open [%d] adapter %d and frontend %d", i, a[i].pa,
 			a[i].fn);
+#ifdef AXE
+		sprintf (buf, "/dev/axe/frontend-%d", a[i].pa);
+#else
 		sprintf (buf, "/dev/dvb/adapter%d/frontend%d", a[i].pa, a[i].fn);
+#endif
 		a[i].fe = open (buf, O_RDWR | O_NONBLOCK);
+
+#ifdef AXE
+		sprintf (buf, "/dev/axe/demuxts-%d", a[i].pa);
+#else
 		sprintf (buf, "/dev/dvb/adapter%d/dvr%d", a[i].pa, a[i].fn);
+#endif
 		a[i].dvr = open (buf, O_RDONLY | O_NONBLOCK);
 		if (a[i].fe < 0 || a[i].dvr < 0)
 		{
@@ -151,10 +165,12 @@ init_hw ()
 
 		num_adapters++;
 		LOG ("opened DVB adapter %d fe:%d dvr:%d", i, a[i].fe, a[i].dvr);
+#ifndef AXE
 		if (ioctl (a[i].dvr, DMX_SET_BUFFER_SIZE, opts.dvr) < 0)
 			perror ("couldn't set DVR buffer size");
 		else
 			LOG ("Done setting DVR buffer to %d bytes", DVR_BUFFER);
+#endif
 		init_dvb_parameters (&a[i].tp);
 		mark_pids_deleted (i, -1, NULL);
 		update_pids (i);
diff --git a/axe.h b/axe.h
new file mode 100644
index 0000000..5af4c73
--- /dev/null
+++ b/axe.h
@@ -0,0 +1,59 @@
+#ifndef __AXE_H
+#define __AXE_H
+
+#include <linux/dvb/dmx.h>
+#include <linux/dvb/frontend.h>
+
+typedef struct fe_frontend_status fe_frontend_status_t;
+
+struct fe_frontend_status {
+  __u32 val0;
+  __u32 val1;
+  __u32 val2;
+  __u32 modulation;
+  __u32 val4;
+  __u32 frequency;
+  __u32 val6;
+  __u32 val7;
+  __u32 symbol_rate;
+  __u32 val9;
+  __u32 fec;
+  __u32 rolloff;
+  __u32 val12;
+  __u32 val13;
+} __attribute__ ((packed));
+
+#define FE_FRONTEND_STANDBY     _IOW('o', 91, __u32)
+#define FE_FRONTEND_RESET	_IO('o', 93)
+#define FE_FRONTEND_STATUS      _IOR('o', 96, fe_frontend_status_t)
+#define FE_FRONTEND_THREAD_UP	_IOW('o', 97, __u8)
+
+static inline int axe_fe_standby(int fd, __u32 stdby)
+{
+  return ioctl(fd, FE_FRONTEND_STANDBY, &stdby);
+}
+
+static inline int axe_fe_reset(int fd)
+{
+  return ioctl(fd, FE_FRONTEND_RESET, 0x54);
+}
+
+static inline int axe_fe_thread_up(int fd, __u8 up)
+{
+  return ioctl(fd, FE_FRONTEND_THREAD_UP, &up);
+}
+
+#define DMXTS_ADD_PID     _IOW('o', 1, __u16)
+#define DMXTS_REMOVE_PID  _IOW('o', 2, __u16)
+
+static inline int axe_dmxts_add_pid(int fd, __u16 pid)
+{
+  return ioctl(fd, DMXTS_ADD_PID, &pid);
+}
+
+static inline int axe_dmxts_remove_pid(int fd, __u16 pid)
+{
+  return ioctl(fd, DMXTS_REMOVE_PID, &pid);
+}
+
+#endif
diff --git a/dvb.c b/dvb.c
index 5701bd2..a06978c 100755
--- a/dvb.c
+++ b/dvb.c
@@ -41,6 +41,10 @@
 #include <ctype.h>
 #include "dvb.h"
 #include "minisatip.h"
+#ifdef AXE
+#include "axe.h"
+#include "adapter.h"
+#endif
 
 extern struct struct_opts opts;
 
@@ -343,6 +347,13 @@ int setup_switch (int frontend_fd, transponder *tp)
 		else 
 			LOGL(3, "Skip sending diseqc commands since the switch position doesn't need to be changed: pol %d, hiband %d, switch position %d", pol, hiband, diseqc);
 	}
+#ifdef AXE
+	LOGL(3, "axe_fe: reset for fd %d", frontend_fd);
+	if (axe_fe_reset(frontend_fd) < 0)
+		LOG("axe_fe: RESET failed for fd %d: %s", frontend_fd, strerror(errno));
+	if (axe_fe_thread_up(frontend_fd, hiband | (pol << 1)) < 0)
+		LOG("axe_fe: THREAD UP failed for fd %d: %s", frontend_fd, strerror(errno));
+#endif
 	
 	tp->old_pol = pol;
 	tp->old_hiband = hiband;
@@ -383,8 +394,10 @@ tune_it_s2 (int fd_frontend, transponder * tp)
 		{.cmd = DTV_INVERSION,.u.data = 0},
 		{.cmd = DTV_SYMBOL_RATE,.u.data = 0},
 		{.cmd = DTV_INNER_FEC,.u.data = 0},
+#ifndef AXE
 		{.cmd = DTV_PILOT,.u.data = 0},
 		{.cmd = DTV_ROLLOFF,.u.data = 0},
+#endif
 		{.cmd = DTV_TUNE},
 	};
 	static struct dtv_properties dvbs2_cmdseq =
@@ -465,8 +478,10 @@ tune_it_s2 (int fd_frontend, transponder * tp)
 			p = &dvbs2_cmdseq;
 			p->props[DELSYS].u.data = tp->sys;
 			p->props[MODULATION].u.data = tp->mtype;
+#ifndef AXE
 			p->props[PILOT].u.data = tp->plts;
 			p->props[ROLLOFF].u.data = tp->ro;
+#endif
 			p->props[INVERSION].u.data = tp->inversion;
 			p->props[SYMBOL_RATE].u.data = tp->sr;
 			p->props[FEC_INNER].u.data = tp->fec;
@@ -475,7 +490,12 @@ tune_it_s2 (int fd_frontend, transponder * tp)
 			LOG("tuning to %d(%d) pol: %s (%d) sr:%d fec:%s delsys:%s mod:%s rolloff:%s pilot:%s, ts clear=%d, ts pol=%d",
 				tp->freq, p->props[FREQUENCY].u.data, get_pol(tp->pol), tp->pol, p->props[SYMBOL_RATE].u.data, fe_fec[p->props[FEC_INNER].u.data],
 				fe_delsys[p->props[DELSYS].u.data], fe_modulation[p->props[MODULATION].u.data],
-				fe_rolloff[p->props[ROLLOFF].u.data], fe_pilot[p->props[PILOT].u.data], bclear, bpol);
+#ifdef AXE
+				"auto", "auto",
+#else
+				fe_rolloff[p->props[ROLLOFF].u.data], fe_pilot[p->props[PILOT].u.data],
+#endif
+				bclear, bpol);
 				
 			break;
 
@@ -560,6 +580,20 @@ set_pid (int hw, int ad, uint16_t i_pid)
 	char buf[100];
 	int fd;
 
+#ifdef AXE
+	adapter *a = get_adapter(hw);
+
+	if ( i_pid > 8192 || a == NULL)
+		LOG_AND_RETURN(-1, "pid %d > 8192 for ADAPTER %d", i_pid, hw);
+
+	if (axe_dmxts_add_pid(a->dvr, i_pid) < 0)
+	{
+		LOG ("failed setting filter on %d (%s)", i_pid, strerror (errno));
+		return -1;
+	}
+	LOG ("setting filter on PID %d for ADAPTER %d", i_pid, a->pa);
+	return (hw << 16) | i_pid;
+#else
 	if ( i_pid > 8192 )
 		LOG_AND_RETURN(-1, "pid %d > 8192 for /dev/dvb/adapter%d/demux%d", i_pid, hw, ad);
 		
@@ -585,6 +619,7 @@ set_pid (int hw, int ad, uint16_t i_pid)
 	}
 
 	LOG ("setting filter on PID %d for fd %d", i_pid, fd);
+#endif
 
 	return fd;
 }
@@ -592,6 +627,17 @@ set_pid (int hw, int ad, uint16_t i_pid)
 
 int del_filters (int fd, int pid)
 {
+#ifdef AXE
+	adapter *a = get_adapter(fd >> 16);
+	if (a == NULL)
+		return 0; /* closed */
+	if ((fd & 0xffff) != pid)
+		LOG_AND_RETURN(0, "AXE PID remove on an invalid handle %d, pid %d", fd, pid);
+	if (axe_dmxts_remove_pid(a->dvr, pid) < 0)
+		LOG ("AXE PID removew failed on PID %d ADAPTER %d: %s", pid, a->pa, strerror (errno))
+			else
+			LOG ("clearing filters on PID %d ADAPTER %d", pid, a->pa);
+#else
 	if (fd < 0)
 		LOG_AND_RETURN(0, "DMX_STOP on an invalid handle %d, pid %d", fd, pid);
 	if (ioctl (fd, DMX_STOP) < 0)
@@ -599,6 +645,7 @@ int del_filters (int fd, int pid)
 			else
 			LOG ("clearing filters on PID %d FD %d", pid, fd);
 	close (fd);
+#endif
 	return 0;
 }
 
@@ -606,6 +653,10 @@ int del_filters (int fd, int pid)
 fe_delivery_system_t
 dvb_delsys (int aid, int fd, fe_delivery_system_t *sys)
 {
+#ifdef AXE
+	LOG ("Delivery System DVB-S2 (AXE)");
+	return sys[0] = SYS_DVBS2;
+#else
 	int i, res, rv = 0;
 	struct dvb_frontend_info fe_info;
 
@@ -703,6 +754,7 @@ dvb_delsys (int aid, int fd, fe_delivery_system_t *sys)
 
 	LOG ("returning default from dvb_delsys => %s (count %d)", fe_delsys[rv] , nsys);
 	return (fe_delivery_system_t) rv;
+#endif
 
 }
 
diff --git a/minisatip.c b/minisatip.c
index d4076ba..581d1bd 100755
--- a/minisatip.c
+++ b/minisatip.c
@@ -483,6 +483,11 @@ http_response (sockets *s, int rc, char *ah, char *desc, int cseq, int lr)
 
 #define RBUF 4000
 
+static inline end_of_header(char *buf)
+{
+	return buf[0] == 0x0d && buf[1] == 0x0a && buf[2] == 0x0d && buf[3] == 0x0a;
+}
+
 int
 read_rtsp (sockets * s)
 {
@@ -507,8 +512,7 @@ read_rtsp (sockets * s)
 		}
 	}
 	
-	if (s->rlen < 4
-		|| (htonl (*(uint32_t *) & s->buf[s->rlen - 4]) != 0x0D0A0D0A))
+	if (s->rlen < 4 || !end_of_header(s->buf + s->rlen - 4))
 	{
 		if( s->rlen > RBUF - 10 )
 		{
@@ -726,8 +730,7 @@ read_http (sockets * s)
 		"%s"
 		"</device></root>";
 
-	if (s->rlen < 5
-		|| (htonl (*(uint32_t *) & s->buf[s->rlen - 4]) != 0x0D0A0D0A))
+	if (s->rlen < 5 || !end_of_header(s->buf + s->rlen - 4))
 	{
 		if( s->rlen > RBUF - 10 )
 		{
@@ -987,7 +990,11 @@ main (int argc, char *argv[])
 	set_options (argc, argv);
 	if (opts.daemon)
 		becomeDaemon ();
+#ifdef AXE
+	LOGL(0, "Starting minisatip version %s, compiled with AXE DVB API",VERSION);
+#else
 	LOGL(0, "Starting minisatip version %s, compiled with dvbapi version: %04X",VERSION, DVBAPIVERSION);
+#endif
 	readBootID();
 	if ((ssdp = udp_bind (NULL, 1900)) < 1)
 		FAIL ("SSDP: Could not bind on udp port 1900");
diff --git a/socketworks.c b/socketworks.c
index b4891f1..1d6f3e0 100755
--- a/socketworks.c
+++ b/socketworks.c
@@ -433,6 +433,17 @@ select_and_execute ()
 					ss->rtime = c_time;
 					if(rlen>0)
 						ss->rlen += rlen;
+#ifdef AXE
+					if (ss->type == TYPE_DVR) {
+						while (rlen > 0 && ss->lbuf - ss->rlen >= 1316) {
+							rlen = read (ss->sock, &ss->buf[ss->rlen], ss->lbuf - ss->rlen);
+							if (rlen > 0)
+								ss->rlen += rlen;
+						}
+						if (rlen == 0)
+							rlen = 1;
+					}
+#endif
 								 //force 0 at the end of the string
 					if(ss->lbuf >= ss->rlen)
 						ss->buf[ss->rlen] = 0;
